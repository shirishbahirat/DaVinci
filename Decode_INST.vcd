$date
	Mon Apr 29 17:26:00 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Test_Decoder_INST $end
$var wire 5 ! rs2 [4:0] $end
$var wire 5 " rs1 [4:0] $end
$var wire 5 # rd [4:0] $end
$var wire 5 $ ls_op [4:0] $end
$var wire 5 % j_op [4:0] $end
$var wire 5 & b_op [4:0] $end
$var wire 10 ' alu_op [9:0] $end
$var wire 32 ( address_imm [31:0] $end
$var reg 32 ) inst [31:0] $end
$scope module test_decode_inst $end
$var wire 32 * inst [31:0] $end
$var reg 32 + address_imm [31:0] $end
$var reg 10 , alu_op [9:0] $end
$var reg 5 - b_op [4:0] $end
$var reg 32 . immr [31:0] $end
$var reg 5 / j_op [4:0] $end
$var reg 5 0 ls_op [4:0] $end
$var reg 5 1 rd [4:0] $end
$var reg 5 2 rs1 [4:0] $end
$var reg 5 3 rs2 [4:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1 3
b10 2
b11 1
b11111 0
b11111 /
b0 .
b11111 -
b10 ,
b0 +
b1000000000100010000000110110011 *
b1000000000100010000000110110011 )
b0 (
b10 '
b11111 &
b11111 %
b11111 $
b11 #
b10 "
b1 !
$end
#5
b1010 '
b1010 ,
b1001 #
b1001 1
b10 !
b10 3
b1 "
b1 2
b1000001110010010110011 )
b1000001110010010110011 *
#10
b101 '
b101 ,
b1 #
b1 1
b1100 !
b1100 3
b111 "
b111 2
b110000111010000010110011 )
b110000111010000010110011 *
#15
b11111111111111111111100001110110 (
b11111111111111111111100001110110 +
b11111111111111111111100001110110 .
b1000000111 '
b1000000111 ,
b11001 #
b11001 1
b0 !
b0 3
b1 "
b1 2
b10000111011000001100110010010011 )
b10000111011000001100110010010011 *
#20
b1010101101 (
b1010101101 +
b1 $
b1 0
b1010101101 .
b1111111111 '
b1111111111 ,
b1101 !
b1101 3
b11110 #
b11110 1
b11 "
b11 2
b101010110100011000111100000011 )
b101010110100011000111100000011 *
#25
b101011100 (
b101011100 +
b1 %
b1 /
b101011100 .
b11111 $
b11111 0
b1 #
b1 1
b0 !
b0 3
b11100 "
b11100 2
b10101110011100000000011100111 )
b10101110011100000000011100111 *
#30
b10110100101011100 (
b10110100101011100 +
b10 %
b10 /
b10110100101011100 .
b10 #
b10 1
b0 "
b0 2
b10101110100010110000101101111 )
b10101110100010110000101101111 *
#35
b11111111111110111111010001011111 (
b11111111111110111111010001011111 +
b100 $
b100 0
b11111111111110111111010001011111 .
b11111 %
b11111 /
b11001 #
b11001 1
b10111111010001011111110010110111 )
b10111111010001011111110010110111 *
#40
b11111111111111101110111001001010 (
b11111111111111101110111001001010 +
b101 $
b101 0
b11111111111111101110111001001010 .
b11110 #
b11110 1
b11101110111001001010111100010111 )
b11101110111001001010111100010111 *
#45
b11111111111111111111111001000011 (
b11111111111111111111111001000011 +
b111 $
b111 0
b11111111111111111111111001000011 .
b11 #
b11 1
b11001 !
b11001 3
b11000 "
b11000 2
b11100101100111000001000110100011 )
b11100101100111000001000110100011 *
#50
b11111111111111111111011010100010 (
b11111111111111111111011010100010 +
b101 &
b101 -
b11111111111111111111011010100010 .
b11111 $
b11111 0
b0 #
b0 1
b1 !
b1 3
b11010 "
b11010 2
b11101010000111010110000101100011 )
b11101010000111010110000101100011 *
#55
